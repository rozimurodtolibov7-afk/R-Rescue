<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>R-Rescue: Cognitive Flow</title>
    <style>
        :root { --core: #fff; --good: #2ecc71; --bad: #e74c3c; --neutral: #f1c40f; }
        body { margin: 0; background: #08080c; overflow: hidden; font-family: 'Monaco', monospace; color: #fff; }
        #ui { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-around; z-index: 10; }
        .stat { font-size: 14px; letter-spacing: 2px; }
        #core-health { width: 150px; height: 4px; background: #222; margin-top: 10px; border-radius: 2px; }
        #health-fill { width: 100%; height: 100%; background: var(--good); transition: 0.3s; }
        canvas { display: block; }
    </style>
</head>
<body>

<div id="ui">
    <div class="stat">COGNITIVE LOAD: <span id="score">0</span>%</div>
    <div class="stat">CORE INTEGRITY <div id="core-health"><div id="health-fill"></div></div></div>
</div>

<canvas id="flowCanvas"></canvas>

<script>
const canvas = document.getElementById('flowCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let nodes = [], score = 0, integrity = 100, gameActive = true;
const corePos = { x: canvas.width/2, y: canvas.height/2, r: 40 };

// Gamma Wave Audio (40Hz focusing frequency)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playFocusFrequency() {
    const masterGain = audioCtx.createGain();
    masterGain.gain.setValueAtTime(0.02, audioCtx.currentTime);
    masterGain.connect(audioCtx.destination);

    const osc1 = audioCtx.createOscillator();
    osc1.frequency.value = 200;
    osc1.connect(masterGain);

    const osc2 = audioCtx.createOscillator();
    osc2.frequency.value = 240; // Binaural beat 40Hz
    osc2.connect(masterGain);

    osc1.start(); osc2.start();
}

function playSoundEffect(freq, type) {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    o.connect(g); g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.1, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
    o.start(); o.stop(audioCtx.currentTime + 0.3);
}

class Node {
    constructor() {
        const side = Math.floor(Math.random() * 4);
        if(side === 0) { this.x = Math.random()*canvas.width; this.y = -20; }
        else if(side === 1) { this.x = canvas.width+20; this.y = Math.random()*canvas.height; }
        else if(side === 2) { this.x = Math.random()*canvas.width; this.y = canvas.height+20; }
        else { this.x = -20; this.y = Math.random()*canvas.height; }

        this.type = Math.random() > 0.6 ? 'bad' : (Math.random() > 0.3 ? 'good' : 'neutral');
        this.s = 1 + Math.random() * 1.5;
        this.r = 10;
        this.isDragged = false;
    }
    update() {
        if(!this.isDragged) {
            const angle = Math.atan2(corePos.y - this.y, corePos.x - this.x);
            this.x += Math.cos(angle) * this.s;
            this.y += Math.sin(angle) * this.s;
        }

        const dist = Math.sqrt((this.x - corePos.x)**2 + (this.y - corePos.y)**2);
        if(dist < corePos.r) this.resolve();
    }
    resolve() {
        if(this.type === 'good') {
            score += 5;
            playSoundEffect(600, 'sine');
        } else if(this.type === 'bad') {
            integrity -= 15;
            playSoundEffect(150, 'sawtooth');
        }
        this.kill();
    }
    kill() {
        nodes = nodes.filter(n => n !== this);
        if(integrity <= 0) gameOver();
    }
}

function spawn() {
    if(Math.random() < 0.03 + (score/2000)) nodes.push(new Node());
}

function draw() {
    ctx.fillStyle = 'rgba(8, 8, 12, 0.3)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw Core
    ctx.shadowBlur = 20;
    ctx.shadowColor = `rgba(255, 255, 255, ${0.2 + Math.sin(Date.now()/500)*0.1})`;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(corePos.x, corePos.y, corePos.r, 0, Math.PI*2); ctx.stroke();
    
    // Core Pulse
    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.beginPath(); ctx.arc(corePos.x, corePos.y, corePos.r + Math.sin(Date.now()/200)*5, 0, Math.PI*2); ctx.fill();

    nodes.forEach(n => {
        n.update();
        ctx.shadowBlur = 10;
        ctx.fillStyle = n.type === 'good' ? '#2ecc71' : (n.type === 'bad' ? '#e74c3c' : '#f1c40f');
        ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath(); ctx.arc(n.x, n.y, n.r, 0, Math.PI*2); ctx.fill();
    });

    document.getElementById('score').innerText = score;
    document.getElementById('health-fill').style.width = integrity + '%';

    if(gameActive) {
        spawn();
        requestAnimationFrame(draw);
    }
}

// Interaction: Drag away BAD nodes
canvas.addEventListener('pointermove', e => {
    nodes.forEach(n => {
        const d = Math.sqrt((e.clientX - n.x)**2 + (e.clientY - n.y)**2);
        if(d < 40 && n.type === 'bad') {
            n.x = -100; // Trash the bad node
            n.kill();
            score += 2;
            playSoundEffect(800, 'sine');
        }
    });
});

function gameOver() {
    gameActive = false;
    alert("Kognitiv yuklama ortdi! Saralangan bilimlar: " + score);
    location.reload();
}

window.addEventListener('mousedown', () => {
    if(audioCtx.state === 'suspended') {
        audioCtx.resume();
        playFocusFrequency();
    }
});

draw();
</script>
</body>
</html>